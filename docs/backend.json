{
  "entities": {
    "UserProfile": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserProfile",
      "type": "object",
      "description": "Represents a user's profile information within the application, excluding authentication details.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the UserProfile entity."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "firstName": {
          "type": "string",
          "description": "The user's first name."
        },
        "lastName": {
          "type": "string",
          "description": "The user's last name."
        },
        "roleId": {
          "type": "string",
          "description": "Reference to the Role assigned to this user. (Relationship: Role 1:N UserProfile)"
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the user profile was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the user profile was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "email",
        "firstName",
        "lastName",
        "roleId",
        "createdAt"
      ]
    },
    "Role": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Role",
      "type": "object",
      "description": "Defines user roles and their associated access levels to different modules.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Role entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the role (e.g., 'Admin', 'Editor', 'Viewer')."
        },
        "description": {
          "type": "string",
          "description": "A detailed description of the role's permissions and responsibilities."
        },
        "moduleIds": {
          "type": "array",
          "description": "References to Modules that this role has access to. (Relationship: Role N:N Module)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "name",
        "moduleIds"
      ]
    },
    "Module": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Module",
      "type": "object",
      "description": "Represents a distinct functional area or section within the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Module entity."
        },
        "name": {
          "type": "string",
          "description": "The display name of the module (e.g., 'Dashboard', 'Projects', 'Documents')."
        },
        "description": {
          "type": "string",
          "description": "A brief description of the module's purpose."
        },
        "icon": {
          "type": "string",
          "description": "A string representing the icon to be used for this module (e.g., an icon font class or SVG path)."
        },
        "path": {
          "type": "string",
          "description": "The navigation path or route associated with this module.",
          "format": "uri-reference"
        }
      },
      "required": [
        "id",
        "name",
        "icon",
        "path"
      ]
    },
    "Project": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Project",
      "type": "object",
      "description": "Represents a distinct project managed within the Excellere Revive application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Project entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the project."
        },
        "description": {
          "type": "string",
          "description": "A detailed description of the project's goals and scope."
        },
        "ownerId": {
          "type": "string",
          "description": "Reference to the UserProfile who owns this project. (Relationship: UserProfile 1:N Project)"
        },
        "startDate": {
          "type": "string",
          "description": "The planned start date for the project.",
          "format": "date"
        },
        "endDate": {
          "type": "string",
          "description": "The planned end date for the project.",
          "format": "date"
        },
        "status": {
          "type": "string",
          "description": "The current status of the project (e.g., 'Active', 'Completed', 'On Hold', 'Archived')."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the project was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the project was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "name",
        "ownerId",
        "startDate",
        "status",
        "createdAt"
      ]
    },
    "Document": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Document",
      "type": "object",
      "description": "Represents a file or document uploaded and associated with a specific project.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Document entity."
        },
        "projectId": {
          "type": "string",
          "description": "Reference to the Project this document belongs to, enabling filtering. (Relationship: Project 1:N Document)"
        },
        "name": {
          "type": "string",
          "description": "The name of the document/file."
        },
        "fileUrl": {
          "type": "string",
          "description": "The URL where the actual file content is stored (e.g., in cloud storage).",
          "format": "uri"
        },
        "fileType": {
          "type": "string",
          "description": "The MIME type of the uploaded file (e.g., 'application/pdf', 'image/jpeg')."
        },
        "fileSize": {
          "type": "number",
          "description": "The size of the file in bytes."
        },
        "uploadedById": {
          "type": "string",
          "description": "Reference to the UserProfile who uploaded this document. (Relationship: UserProfile 1:N Document)"
        },
        "uploadDate": {
          "type": "string",
          "description": "Timestamp when the document was uploaded.",
          "format": "date-time"
        },
        "description": {
          "type": "string",
          "description": "An optional description or summary of the document's content."
        }
      },
      "required": [
        "id",
        "projectId",
        "name",
        "fileUrl",
        "fileType",
        "fileSize",
        "uploadedById",
        "uploadDate"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/user_profiles/{userProfileId}",
        "definition": {
          "entityName": "UserProfile",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "Stores individual user profiles. The userProfileId must match the authenticated user's UID (request.auth.uid). To ensure Authorization Independence and DBAC, this document will also denormalize the 'moduleIds' array from the associated 'Role' document, directly listing the modules the user has access to. This allows security rules to check module access without requiring a 'get()' call to the /roles collection. (e.g., UserProfile in Firestore: { ..., roleId: 'adminRole', moduleIds: ['dashboard', 'projects', 'documents'], ... }).",
          "params": [
            {
              "name": "userProfileId",
              "description": "The unique identifier of the user profile, which must correspond to the Firebase Authentication UID."
            }
          ]
        }
      },
      {
        "path": "/roles/{roleId}",
        "definition": {
          "entityName": "Role",
          "schema": {
            "$ref": "#/backend/entities/Role"
          },
          "description": "Stores definitions of user roles and their associated module access. These documents are generally read-only for most users and managed by administrators. While the 'moduleIds' field exists here, for authorization rules, it is denormalized into the UserProfile documents.",
          "params": [
            {
              "name": "roleId",
              "description": "The unique identifier for the role."
            }
          ]
        }
      },
      {
        "path": "/modules/{moduleId}",
        "definition": {
          "entityName": "Module",
          "schema": {
            "$ref": "#/backend/entities/Module"
          },
          "description": "Stores definitions of application modules, including their names, descriptions, icons, and navigation paths. These are global, read-only configuration data.",
          "params": [
            {
              "name": "moduleId",
              "description": "The unique identifier for the module."
            }
          ]
        }
      },
      {
        "path": "/projects/{projectId}",
        "definition": {
          "entityName": "Project",
          "schema": {
            "$ref": "#/backend/entities/Project"
          },
          "description": "Stores details for each project. Authorization is based on the 'ownerId' field within the document, ensuring Authorization Independence as rules can directly check resource.data.ownerId against request.auth.uid.",
          "params": [
            {
              "name": "projectId",
              "description": "The unique identifier for the project."
            }
          ]
        }
      },
      {
        "path": "/projects/{projectId}/documents/{documentId}",
        "definition": {
          "entityName": "Document",
          "schema": {
            "$ref": "#/backend/entities/Document"
          },
          "description": "Stores metadata for files uploaded related to a specific project. This subcollection structure naturally links documents to their parent project, fulfilling the requirement for project-based filtering. For Authorization Independence, each Document document will denormalize the 'projectOwnerId' (from its parent Project) in addition to its own 'uploadedById', allowing security rules to verify access based on project ownership without performing a 'get()' on the parent Project document. Includes denormalized 'projectOwnerId' for authorization independence.",
          "params": [
            {
              "name": "projectId",
              "description": "The unique identifier of the parent project this document belongs to."
            },
            {
              "name": "documentId",
              "description": "The unique identifier for the document within the project."
            }
          ]
        }
      }
    ],
    "reasoning": "The recommended Firestore structure is designed with a strong emphasis on Authorization Independence, enabling robust and debuggable security rules. Each entity is placed in a collection or subcollection that logically groups items with similar security postures.\n\nKey aspects of the design are:\n\n1.  **Authorization Independence via Denormalization:**\n    *   **User Profiles (`/user_profiles/{userProfileId}`):** To facilitate role-based access control (DBAC) without relying on `get()` calls in security rules, the `moduleIds` (representing the modules a user has access to) should be denormalized and stored directly within each `UserProfile` document. This allows rules to perform direct checks like `resource.data.moduleIds.hasAny('someModuleId')` alongside `request.auth.uid == userProfileId`, ensuring atomic authorization decisions.\n    *   **Projects (`/projects/{projectId}`):** Project ownership is clearly defined by the `ownerId` field within each `Project` document. This makes project-level access rules straightforward and independent, as rules can directly compare `request.auth.uid` with `resource.data.ownerId`.\n    *   **Documents (`/projects/{projectId}/documents/{documentId}`):** Documents are structured as a subcollection under their respective projects. To maintain authorization independence for documents, the `projectOwnerId` (the owner of the parent project) is denormalized and included in each `Document` document. This allows security rules to authorize document access based on project ownership (`request.auth.uid == resource.data.projectOwnerId`) or upload authorship (`request.auth.uid == resource.data.uploadedById`) without needing to perform a `get()` operation on the parent `Project` document.\n\n2.  **Structural Segregation and QAPs (Rules are not Filters):**\n    *   **Global Entities (`/roles`, `/modules`):** These collections hold configuration data that is generally read-only for most users or managed by administrators. Their security posture is homogeneous, simplifying rules.\n    *   **User-Owned Data (`/user_profiles`):** Access to a `UserProfile` document is typically restricted to the authenticated user matching the `userProfileId`. Rules can strictly enforce this `request.auth.uid == userProfileId` condition, enabling secure `get` operations for specific profiles.\n    *   **Project-Owned Data (`/projects`):** All documents within the `/projects` collection represent distinct projects. Rules can enforce that users can only `list` or `read/write` projects where `resource.data.ownerId == request.auth.uid`. This fulfills the QAP principle as queries will implicitly leverage an index on `ownerId` for efficient and secure retrieval of user-specific projects, and the rule will ensure no unauthorized projects are returned.\n    *   **Project-Specific Documents (`/projects/{projectId}/documents`):** This hierarchical structure directly addresses the requirement that documents must be associated with a selected project and function as a filter. When querying documents for a specific `projectId`, the path itself acts as the primary filter. Security rules will then build upon this by ensuring the authenticated user either owns the parent project (via denormalized `projectOwnerId`) or is the uploader (`uploadedById`). This ensures that `list` operations within a project are secure and that the rules don't act as ad-hoc filters, but rather enforce the authorization on already-filtered (by path) data."
  }
}